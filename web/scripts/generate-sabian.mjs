// scripts/generate-sabian.mjs
import fs from "node:fs";
import path from "node:path";

const OUT_PATH = path.resolve(process.cwd(), "src/lib/sabian/uraSabian.ts");

const SIGNS = [
  "Aries",
  "Taurus",
  "Gemini",
  "Cancer",
  "Leo",
  "Virgo",
  "Libra",
  "Scorpio",
  "Sagittarius",
  "Capricorn",
  "Aquarius",
  "Pisces",
];

function mustEnv(name) {
  const v = process.env[name];
  if (!v) throw new Error(`Missing env ${name}`);
  return v;
}

function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

function buildDegreeKeys() {
  const keys = [];
  for (let s = 0; s < 12; s++) {
    for (let d = 1; d <= 30; d++) {
      const idx = s * 30 + (d - 1);
      keys.push({ idx, sign: SIGNS[s], degree: d, key: `${SIGNS[s]} ${d}` });
    }
  }
  return keys;
}

function systemPrompt() {
  return `
You are generating URA's Sabian Degree Reference dataset.

Hard rules:
- Write ORIGINAL text. Do NOT reproduce any canonical Sabian symbol phrases.
- You may be inspired by the tradition, but every line must be reworded into URA voice.
- No predictions. No fortune-telling. No guaranteed outcomes.
- Keep each field concise and actionable.

Return ONLY valid JSON with this shape:
{
  "entries": [
    {
      "idx": 0-359,
      "key": "Sign Degree",
      "sign": "Sign",
      "degree": 1-30,
      "symbol": "1 short image line (original wording)",
      "signal": "what is active (1 sentence)",
      "shadow": "what to watch (1 sentence)",
      "directive": "what to do (1 sentence)",
      "practice": "one concrete behavior (imperative)",
      "journal": "one question",
      "tags": ["3-6 short tags"]
    }
  ]
}
`.trim();
}

function userPrompt(batch) {
  return `
Generate URA Sabian entries for this batch:

${batch.map((x) => `${x.idx}: ${x.key}`).join("\n")}

Notes:
- "symbol" should feel like a symbolic snapshot you could place on a calendar degree.
- "practice" must be a specific behavior (not abstract).
- "journal" must be a single question.

Return JSON only.
`.trim();
}

async function callOpenAI({ apiKey, model, content }) {
  const r = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      Authorization: `Bearer ${apiKey}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      model,
      temperature: 0.35,
      response_format: { type: "json_object" },
      messages: [
        { role: "system", content: systemPrompt() },
        { role: "user", content },
      ],
    }),
  });

  const data = await r.json();
  if (!r.ok) {
    const msg = data?.error?.message || `OpenAI error ${r.status}`;
    throw new Error(msg);
  }
  const txt = data?.choices?.[0]?.message?.content || "";
  return JSON.parse(txt);
}

function validateEntries(entries) {
  if (!Array.isArray(entries)) throw new Error("entries is not an array");
  for (const e of entries) {
    if (typeof e.idx !== "number") throw new Error("entry missing idx");
    if (typeof e.key !== "string") throw new Error("entry missing key");
    if (typeof e.sign !== "string") throw new Error("entry missing sign");
    if (typeof e.degree !== "number") throw new Error("entry missing degree");
    for (const k of ["symbol", "signal", "shadow", "directive", "practice", "journal"]) {
      if (typeof e[k] !== "string" || !e[k].trim()) throw new Error(`entry ${e.idx} missing ${k}`);
    }
    if (!Array.isArray(e.tags)) e.tags = [];
    e.tags = e.tags.filter((t) => typeof t === "string").slice(0, 8);
  }
  return entries;
}

function writeTS(entries) {
  const header = `// src/lib/sabian/uraSabian.ts
// AUTO-GENERATED by scripts/generate-sabian.mjs
// Do not edit manually (regenerate instead).

export type UraSabianEntry = {
  idx: number;
  key: string;
  sign: string;
  degree: number;
  symbol: string;
  signal: string;
  shadow: string;
  directive: string;
  practice: string;
  journal: string;
  tags?: string[];
};

export const URA_SABIAN: UraSabianEntry[] = ${JSON.stringify(entries, null, 2)} as const;
`;
  fs.writeFileSync(OUT_PATH, header, "utf8");
}

async function main() {
  const apiKey = mustEnv("OPENAI_API_KEY");
  const model = (process.env.URA_OPENAI_MODEL || process.env.OPENAI_MODEL || "gpt-4.1-mini").trim();

  const all = buildDegreeKeys();
  const batchSize = 24; // safe-ish chunk size
  const out = new Array(360);

  for (let i = 0; i < all.length; i += batchSize) {
    const batch = all.slice(i, i + batchSize);
    const content = userPrompt(batch);

    console.log(`Generating ${batch[0].idx}..${batch[batch.length - 1].idx}`);
    const json = await callOpenAI({ apiKey, model, content });

    const entries = validateEntries(json.entries);

    for (const e of entries) {
      if (e.idx < 0 || e.idx > 359) continue;
      out[e.idx] = e;
    }

    // small pause to avoid rate spikes
    await sleep(350);
  }

  // ensure all filled
  for (let i = 0; i < 360; i++) {
    if (!out[i]) throw new Error(`Missing entry idx ${i}`);
  }

  writeTS(out);
  console.log(`✅ Wrote ${OUT_PATH}`);
}

main().catch((e) => {
  console.error("❌ generate-sabian failed:", e);
  process.exit(1);
});
